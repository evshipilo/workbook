// Эта презентация ставит цель за 10 минут разобраться в основах внедрения зависимостей на простейших примерах.
// Для желающих углубиться в тему в конце будут предоставлены ссылки на полезные ресурсы.
// Для того чтобы разобраться что такое внедрение зависимостей и для чего оно нужно давайте рассмотрим пример,
// Для наглядности и упрощения в примерах будем использовать обычные JS функции, но все это актуально для 
// функций конструкторов и для классов.

function user(name, age) {
    return {name, age}
}

function checkUser(userName, userAge) {
    const user = user(userName, userAge);
    // actions with the user object
}

checkUser('John', 30);

// У нас типичная ситуация, с которой часто встречаются разработчики,
// функция user возвращает обьект, а функции checkUser необходим этот обьект для правильной 
// работы. Тогда мы можем сказать, что функция checkUser зависит от обьекта, предоставляемого функцией user или
// этот обьект является зависимостью функции checkUser. 
// Теперь мы можем подумать, как передать этот обьект в функцию checkUser, или другими словами
// как инжектировать зависимость. В данном примере мы получили требуемый обьект в теле функции checkUser,
// или другими словами инжектировали зависимость в теле функции.
// И все вроде бы хорошо, но такой подход иногда вызывает проблемы.
// Давайте мы изменим функцию user (например добавим параметр surname)

function user(name, surname, age) {
    return {name, surname, age}
}

function checkUser(userName, userSurname, userAge) {
    const user = user(userName, userSurname, userAge);
    // actions with the user object
}

checkUser('John', 'Adams', 30);

//  Мы видим, что после изменений в функции user, нам пришлось внести изменения и в функцию checkUser
// чтобы она правильно работала с функцией user.
//  Получается, что одна функция зависит от имплементации другой, что нарушает один из принципов SOLID -
//  принцип инверсии зависимостей (Dependency Inversion Principle, DIP) -- Высокоуровневые модули не
// должны зависеть от низкоуровневых;
//  В приложении при изменениях в функции user мы должны найти все места её использования в других функциях
// и внести изменения, что очень не удобно.
//  К тому же теперь в функцию checkUser нам нужно передать уже не 2 а 3 аргумента. А если представить
//  что и она может использоваться в более высокоуровневых функциях - то изменения в одной функции могут
// вызвать
//  лавинообразную последовательность изменений в приложении. (нарушение паттерна GRASP  
// Low Coupling. Если объекты в приложении сильно связанны, то любой их изменение приводит к изменениям во всех связанных
// объектах. А это неудобно и порождает множество проблем.)
//  Так же возникают сложности с тестированием функции checkUser, подменить реализацию функции user не 
//представляется возможным,
//  ведь она точно указана в месте своего использования. И если тесты для checkUser не будут проходить, 
//будет сложно определить - ошибка в самой checkUser
//  или в функции user.
//  Итак, понимая, что внедрение зависимостей в теле зависимой функции — не самая лучшая идея, давайте 
//попробуем альтернативный способ.
//  Передадим нужные зависимости (т.е. обьект возвращаемый функцией user) в виде аргумента функции checkUser.

function checkUser(user) {
    // actions with the user object
}

checkUser(user('John', 'Adams', 30));

// Такой подход называется внедрение зависимостей через аргументы функции или  через аргументы конструктора (для классов).
// Теперь функции user и checkUser слабо связаны, имплементация checkUser не зависит от функции user.
// Более того вместо обьекта возвращаемого функцией user мы можем передать в качестве аргумента функции checkUser другой обьект,
// например во время тестов.

// Давайте подитожим
// 1) Мы часто сталкиваемся с внедрением зависимостей не задумываясь об этом, например когда передаем обьект в функцию.
// 2) Когда это возможно следует избегать внедрения зависимостей в теле функции.
// 3) Внедрение зависимостей в качестве аргументов фунции (или конструктора) позволяет 
//    -- уменьшить связанность функций
//    -- облегчить тестирование
//    -- следовать принципам 'Keep it simple, stupid' и 'Don't repeat yourself'
 


// теперь давайте подумаем, достаточно ли этого подхода?
// несмотря на всю его простоту, такой подход в большом приложении может стать не масштабируемым,
// Представим что у функции, может быть много зависимостей, у которых могут быть свои зависимости,
// тогда проверить наличие зависимостей, соответствие их типам, создать экземпляры зависимостей,
// правильно и в нужном порядке их передать
// становится не тривиальной задачей, сложность которой растет по мере усложнения проекта.

//  Для решения этой проблемы воспользуемся паттерном Inversion of Control (IoC) - суть которого в том,
// что разработчик часть своих полномочий отдает на
//  откуп внешней программой сущности — функции, библиотеке или фреймворку. Касательно DI, IoC заключается 
// в том, что мы просто указываем зависимости
//  при  описании функции или класса. А созданием экземпляров этих зависимостей управляет какой-то 
// внешний код, например контейнер внедрения зависимостей
//  Dependency Injection Container (DIC).

// Давайте посмотрим как это организовано во фреймворке Angular.
// Это простейший пример, декоратор @Injectable помечает класс HeroService как доступный для внедрения
// в качестве зависимости.
// В декораторе @Component класса HeroListComponent в поле providers укажем наш HeroService. 
// providers - это инструкция для системы внедрения зависимостей Angular о том, как получить экземляр зависимости.
// Когда Angular создает новый экземпляр компонента HeroListComponent,
//  он определяет, какие зависимости нужны этому классу, просматривая типы 
//  параметров конструктора.
//  Когда Angular обнаруживает, что компонент HeroListComponent зависит от HeroService, инжектор создает (если требуется)
//  экземпляр HeroService и вызвает конструктор компонента HeroListComponent
//  с экземпляром HeroService в качестве аргумента.
// Все что требуется от разработчика - указать тип зависимости в конструкторе класса, всю остальную работу
// по внедрению зависимости Angular  выполнит сам.
// Это только один из множества возможных вариантов внедрения 
// зависимостей в Angular. Мы разобрали его для 
//  понимания базовой концепции внедрения зависимотей.

@Injectable()
class HeroService {
    doSomething(){}
}

@Component({
    selector: 'hero-list',
    template: '...',
    providers: [HeroService]
  })
  class HeroListComponent {
    constructor(private heroService: HeroService) {}
    this.heroService.doSomething()
  }








