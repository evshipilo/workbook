// Для того чтобы разобраться что такое внедрение зависимостей и для чего оно нужно давайте рассмотрим пример

class Tires {
  constructor(size) {
    this.size = size;
  }
}

class Car {
  constructor(name, size) {
    this.name = name;
    this.tires = new Tires(size);
  }
}

const someCar1 = new Car('Volvo', 19);

// Мы видим, что классу Car требуется инстанс класса Tires для корректной работы.
// Можно сказать что Car зависит от класса Tires или класс Tires является зависимостью класса Car.
// Этот пример рабочий, в классе Car успешно инициализируется поле tires инстансом класса Tires.
// Однако такой подход вызывает проблемы.
// Давайте мы изменим имплементацию класса Tires (например добавим параметр конструктора)

class Tires {
  constructor(size, vendor) {
    this.size = size;
    this.vendor = vendor;
  }
}

class Car {
  constructor(name, size, vendor) {
    this.name = name;
    this.tires = new Tires(size, vendor);
  }
}

const someCar2 = new Car('Volvo', 19, 'Pirelli');

//  Мы видим, теперь чтобы правильно получить инстанс класса Tires в Car нам нужно внести изменения в класс Car.
//  Получается, что один класс зависит от имплементации другого, что нарушает один из принципов SOLID -
//  принцип инверсии зависимостей (Dependency Inversion Principle, DIP) -- Высокоуровневые модули не должны зависеть от низкоуровневых;
//  оба типа должны зависеть от абстракций.
//  При изменениях в классе Tires мы должны найти все места его использования в других классах и внести изменения, что очень не удобно.
//  К тому же теперь чтобы получить инстанс класса Car нам нужно передать уже не 2 а 3 аргумента. А если представить
//  что и класс Car может использоваться в более высокоуровневых модулях - то изменения в одном классе могут вызвать
//  лавинообразную последовательность изменений в приложении.
//  Так же возникают сложности с тестированием Car, подменить реализацию Tires не представляется возможным,
//  ведь он прямо жестко закодирован в месте своего использования.
//  Итак, понимая, что внедрение зависимостей внутри зависимого класса — не самая лучшая идея, давайте попробуем альтернативный способ.
//  Передадим нужные зависимости в параметры конструктора класса Car.

class Tires {
  constructor(size, vendor) {
    this.size = size;
    this.vendor = vendor;
  }
}

class Car {
  constructor(name, tires) {
    this.name = name;
    this.tires = tires;
  }
}

const someCar3 = new Car('Volvo', new Tires(19, 'Pirelli'));

// Такой подход называется внедрение зависимостей через конструктор. Теперь классы Car и Tires слабо связаны, имплементация класса Car не зависит от Tires.
// Более того вместо инстанса класса Tires мы можем передать инстанс другого класса.
// Class Car теперь можно протестировать. При написании теста, мы можем создать нашу собственную версию класса Tires (тестовый объект) и передать её в Car.

// теперь давайте подумаем, достаточно ли этого подхода?
// несмотря на всю его простоту, такой подход в большом приложении может стать не масштабируемым,
// Представим что у модуля, может быть много зависимостей, у которых могут быть свои зависимости,
// тогда проверить наличие зависимостей, соответствие их типам, создать инстансы зависимостей, правильно и в нужном порядке их передать
// становится не тривиальной задачей, сложность которой растет по мере усложнения проекта.

//  Для решения этой проблемы воспользуемся паттерном Inversion of Control (IoC) - суть которого в том, что разработчик часть своих полномочий отдает на
//  откуп внешней программой сущности — функции, библиотеке или фреймворку. Касательно DI, IoC заключается в том, что мы просто указываем зависимости
//  при  описании класса. А созданием инстансов этих зависимостей управляет какой-то внешний код, например контейнер внедрения зависимостей
//  Dependency Injection Container (DIC) при инициализации инстанса основного класса.

// Давайте посмотрим как это организовано во фреймворке Angular.
// В системе внедрения зависимостей существуют две основные роли: потребитель зависимостей и поставщик зависимостей.
// Angular облегчает взаимодействие между потребителями зависимостей и поставщиками зависимостей с помощью абстракции под названием Injector. 
// Когда запрашивается зависимость, инжектор проверяет свой реестр, чтобы увидеть, есть ли там уже доступный экземпляр. 
// Если нет, новый экземпляр создается и сохраняется в реестре.
// Представьте, что есть класс HeroService, который должен действовать как зависимость в компоненте. 
// Первый шаг — добавить декоратор @Injectable, чтобы показать, что класс можно внедрить.

@Injectable()
class HeroService {
    doSomething(){}
}

// На уровне компонента в поле провайдеров декоратора @Component укажим HeroService. В этом случае HeroService становится доступным для всех 
// экземпляров этого компонента и новый экземпляр HeroService будет создаваться для каждого нового экземпляра HeroListComponent.

@Component({
    selector: 'hero-list',
    template: '...',
    providers: [HeroService]
  })
  class HeroListComponent {
    constructor(private heroService: HeroService) {}
    this.heroService.doSomething()
  }

//  Наиболее распространенный способ внедрить зависимость — объявить ее в конструкторе класса. Когда Angular создает новый экземпляр компонента,
//  он определяет, какие сервисы или другие зависимости нужны этому классу, просматривая типы параметров конструктора. 
//  Когда Angular обнаруживает, что компонент зависит от HeroService, инжектор создает его экземпляр и вызвает конструктор компонента 
//  с экземпляром HeroService в качестве аргумента. Это только один из возможных вариантов внедрения зависимостей в Angular. Мы разобрали его для 
//  понимания базовой концепции внедрения зависимотей.








