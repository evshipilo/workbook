// Эта презентация ставит цель разобраться в основах внедрения зависимостей на простейших примерах.
// Для желающих углубиться в тему в конце будут предоставлены ссылки на полезные ресурсы.
// Для того чтобы разобраться что такое внедрение зависимостей и для чего оно нужно давайте рассмотрим пример,
// Для наглядности и упрощения в примерах будем использовать обычные JS функции, но все это актуально для 
// функций конструкторов и для классов.

function user(name, age) {
    return {name, age}
}

function checkUser(userName, userAge) {
    const user = user(userName, userAge);
    // действия с обьектом user
}

checkUser('John', 30);

// На самом деле это очень распространенный пример, вызов функции в функции, такое мы видим ежедневно.
// Функции checkUser для корректной работы требуется обьект предоставляемый функцией user.
// Можно сказать что функция checkUser зависит от функциии user или функция user является зависимостью функциии checkUser.
// Этот пример рабочий, в функции checkUser успешно создается объект user.
// Однако такой подход иногда вызывает проблемы.
// Давайте мы изменим функцию user (например добавим параметр surname)

function user(name, surname, age) {
    return {name, surname, age}
}

function checkUser(userName, userSurname, userAge) {
    const user = user(userName, userSurname, userAge);
    // действия с обьектом user
}

checkUser('John', 'Adams', 30);

//  Мы видим, что после изменений в функции user, нам пришлось внести изменения и в функцию checkUser чтобы она правильно работала с функцией user.
//  Получается, что одна функция зависит от имплементации другой, что нарушает один из принципов SOLID -
//  принцип инверсии зависимостей (Dependency Inversion Principle, DIP) -- Высокоуровневые модули не должны зависеть от низкоуровневых;
//  оба типа должны зависеть от абстракций.
//  В приложении при изменениях в функции user мы должны найти все места её использования в других функциях и внести изменения, что очень не удобно.
//  К тому же теперь в функцию checkUser нам нужно передать уже не 2 а 3 аргумента. А если представить
//  что и она может использоваться в более высокоуровневых модулях - то изменения в одной функции могут вызвать
//  лавинообразную последовательность изменений в приложении.
//  Так же возникают сложности с тестированием функции checkUser, подменить реализацию функции user не представляется возможным,
//  ведь она точно указана в месте своего использования. И если тесты для checkUser не будут проходить, будет сложно определить - ошибка в самой checkUser
//  или в функции user.
//  Итак, понимая, что внедрение зависимостей внутри зависимой функции — не самая лучшая идея, давайте попробуем альтернативный способ.
//  Передадим нужные зависимости в виде аргументов функции checkUser.

function checkUser(user) {
    // действия с обьектом user
}

checkUser(user('John', 'Adams', 30));

// Такой подход называется внедрение зависимостей через параметры функции или  через конструктор (для классов).
// То есть двумя словами - внедрение зависимостей это передача обьектов в параметры функции вместо получения их в теле функции.
// Теперь функции user и checkUser  слабо связаны, имплементация checkUser не зависит от функции user.
// Более того вместо обьекта возвращаемого функцией user мы можем передать в качестве аргумента другой обьект, например во время тестов.

// теперь давайте подумаем, достаточно ли этого подхода?
// несмотря на всю его простоту, такой подход в большом приложении может стать не масштабируемым,
// Представим что у модуля, может быть много зависимостей, у которых могут быть свои зависимости,
// тогда проверить наличие зависимостей, соответствие их типам, создать инстансы зависимостей, правильно и в нужном порядке их передать
// становится не тривиальной задачей, сложность которой растет по мере усложнения проекта.

//  Для решения этой проблемы воспользуемся паттерном Inversion of Control (IoC) - суть которого в том, что разработчик часть своих полномочий отдает на
//  откуп внешней программой сущности — функции, библиотеке или фреймворку. Касательно DI, IoC заключается в том, что мы просто указываем зависимости
//  при  описании функции или класса. А созданием экземпляров этих зависимостей управляет какой-то внешний код, например контейнер внедрения зависимостей
//  Dependency Injection Container (DIC).

// Давайте посмотрим как это организовано во фреймворке Angular.
// В системе внедрения зависимостей существуют две основные роли: потребитель зависимостей и поставщик зависимостей.
// Angular облегчает взаимодействие между потребителями зависимостей и поставщиками зависимостей с помощью абстракции под названием Injector. 
// Когда запрашивается зависимость, инжектор проверяет свой реестр, чтобы увидеть, есть ли там уже доступный экземпляр. 
// Если нет, новый экземпляр создается и сохраняется в реестре.
// Представьте, что есть класс HeroService, который должен действовать как зависимость в компоненте. 
// Первый шаг — добавить декоратор @Injectable, чтобы показать, что класс можно внедрить.

@Injectable()
class HeroService {
    doSomething(){}
}

// На уровне компонента в поле провайдеров декоратора @Component укажим HeroService. В этом случае HeroService становится доступным для всех 
// экземпляров этого компонента и новый экземпляр HeroService будет создаваться для каждого нового экземпляра HeroListComponent.
// Angular даёт так же возможность зарегистрировать зависимости на разных уровнях и нескольким потребителям зависимости получать синглтон этой зависимости,
// не создавать каждый раз экземпляр зависимости а пользоваться общим экземпляром.

@Component({
    selector: 'hero-list',
    template: '...',
    providers: [HeroService]
  })
  class HeroListComponent {
    constructor(private heroService: HeroService) {}
    this.heroService.doSomething()
  }

//  Наиболее распространенный способ внедрить зависимость — объявить ее в конструкторе класса. Когда Angular создает новый экземпляр компонента,
//  он определяет, какие сервисы или другие зависимости нужны этому классу, просматривая типы параметров конструктора. 
//  Когда Angular обнаруживает, что компонент зависит от HeroService, инжектор создает (если требуется) его экземпляр и вызвает конструктор компонента 
//  с экземпляром HeroService в качестве аргумента. Это только один из возможных вариантов внедрения зависимостей в Angular. Мы разобрали его для 
//  понимания базовой концепции внедрения зависимотей.








